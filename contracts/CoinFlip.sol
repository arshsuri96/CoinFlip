pragma solidity ^0.8.26;

import "@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol";

contract CoinFlip is VRFV2WrapperConsumerBase{

    event CoinFlipRequest(uint256 requestId);
    event CoinFlipResult(uint256 requestId, bool didWin);

    struct CoinFlipStatus {
        uint256 Fee; //Chainlink charges fee for the complexity of the randomWord generated by your function, keep the track of Fee
        uint256 randomWord; 
        address player;
        bool didWin; //keep a tab of the winning
        bool fulfilled; //did chainlink fulfill the request, maybe an async function 
        CoinFlipSelection choice; 
    }

    enum CoinFlipSelection {
        HEADS,
        TAILS
    }

    address constant wrapperAddress = 0xa555fC018435bef5A13C6c6870a9d4C11DEC329C;
    address constant linkAddress = 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06;

    uint128 constant entryFees = 0.001 ether; //pay when make the prediction
    uint32 constant callbackGasLimit = 1000000;
    uint32 constant numWords = 1;
    uint16 constant requestConfirmations = 3;


    mapping(uint256 => CoinFlipStatus) public status; //from requestId. can be used by anyone on the network 
    
    constructor () VRFV2WrapperConsumerBase(linkAddress, wrapperAddress) {}

    function flip(CoinFlipSelection choice) external payable returns (uint256) {
        require(msg.sender == entryFees, "Entry fees not sent");
        uint256 requestId = requestRandomness ( //this fx is coming from VRF
            callbackGasLimit,
            requestConfirmations,
            numWords
        );

        status[requestId] = CoinFlipRequest({
            fees: VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit),
            randomWord: 0,
            player: msg.sender,
            didWin: false,
            fulfilled: false,
            choice: choice
        });

        emit CoinFlipRequest(requestId);
        return requestId;
    }

    function fulfillRandomWrods(uint256 requests, uint256[] memory randomWrods) internal override {
        require(status[requestId].fees > 0, "Request not found");

        status[requestId].fulfilled = true;
        status[requestId].randomWord = randomWord[0];

        CoinFlipSelection result = CoinFlipSelection.HEAD;
        if(randomWord%2==0) {
            result = CoinFlipSelection.TAILS
        }

        if status[requestId].choice == result {
            status[requestId].didWin = true;

            payable(status[requestId].[player]).transfer(entryFees*2);
        }

        emit CoinFlipResult(requestId, status[requestId].didWin);
    }
    


}